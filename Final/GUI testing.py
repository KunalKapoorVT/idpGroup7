from bleak import BleakScanner, BleakClient;
from datetime import datetime;
import asyncio;
import pygame;
import Tractor;
import math;

plotting = True

try:
    import matplotlib.pyplot as plt
except:
    plotting = False


class Button():
    def __init__(self, surface=None, x=None, y=None, width=50, height=50, color=(128, 128, 128)):
        self.surface = surface
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.text = None

    def setText(self, text):

        self.text = font.render(text, True, (0, 0, 0))

    def draw(self, surface=None, x=None, y=None):
        if (surface == None):
            surface = self.surface
        if (x == None):
            x = self.x
        if (y == None):
            y = self.y

        pygame.draw.rect(surface, self.color, (x, y, self.width, self.height))
        surface.blit(self.text, (x + 50, y + 40, 150, 100))

    def bind(self, function):

        self.run = function

    def inside(self, x, y):
        return x > self.x and x < self.x + self.width and y > self.y and y < self.y + self.height


def sendReportToFile(tractor):
    out = ''

    tapes = tractor.estTapes
    obstacles = tractor.estObstacles
    controls = tractor.userControlEvents

    tapesIter = 0
    obstaclesIter = 0
    controlsIter = 0
    obstacleStarted = False

    while (tapesIter < len(tapes) or obstaclesIter < len(obstacles) or controlsIter < len(controls)):

        if tapesIter < len(tapes):
            tape = tapes[tapesIter]
        else:
            tape = [math.inf]

        if obstaclesIter < len(obstacles):
            obstacle = obstacles[obstaclesIter]
        else:
            obstacle = [math.inf, 0, 0, None]

        if controlsIter < len(controls):
            control = controls[controlsIter]
        else:
            control = [math.inf, 0]

        tapeTime = tape[0]
        obstacleStartTime = obstacle[0]
        obstacleEndTime = obstacle[3]
        userControlTime = control[0]

        if not obstacleStarted:
            time = min(tapeTime, obstacleStartTime, userControlTime);

        elif obstacleEndTime != None:
            time = min(tapeTime, obstacleEndTime, userControlTime);

        else:
            time = min(tapeTime, userControlTime);

        if (time == tapeTime):
            out += "%f: Tape encountered at X=%s Y=%s Facing %s\n" % (time, tape[1], tape[2], tape[3])
            tapesIter += 1

        if (time == obstacleStartTime):
            out += "%f: Obstacle encountered at X=%s Y=%s\n" % (time, obstacle[1], obstacle[2])

            obstacleStarted = True

        if (time == obstacleEndTime):
            out += "%f: Previous obstacle removed\n" % (time)
            obstacleStarted = False
            obstaclesIter += 1

        if (time == userControlTime):
            msg = "Start" * control[1] + "Stop" * (not control[1])
            out += "%f: User told tractor to %s\n" % (time, msg)
            controlsIter += 1

    out += "%f: Report generated by tractor at X=%s Y=%s Facing %s" % (
    tractor.time(), tractor.prevEstX, tractor.prevEstY, tractor.AngleZ)

    with open('Tractor Report %s.log' % (datetime.now().strftime("%Y%M%d%H%M%S")), 'w+') as f:
        f.write(out)

    print("report generated")

    if plotting:
        plt.plot([x[1] for x in tractor.estimatedXVals], [y[1] for y in tractor.estimatedYVals], label="Tractor")
        plt.plot([x[1] for x in tractor.estObstacles], [y[2] for y in tractor.estObstacles], 'o', label="Obstacles")
        plt.plot([x[1] for x in tractor.estTapes], [y[2] for y in tractor.estTapes], 'o', label="Tapes")
        plt.legend()
        plt.show()


async def main():
    global tractor

    await tractor.connect()

    await tractor.setRecv()

    pygame.init()
    screen = pygame.display.set_mode((600, 600))

    pygame.display.set_caption("IDP Group 7 Pygame Tractor GUI")

    global font
    font = pygame.font.Font('freesansbold.ttf', 32)

    startButton = Button(screen, 50, 50, 500, 100)
    stopButton = Button(screen, 50, 200, 500, 100)
    reportButton = Button(screen, 50, 350, 500, 100)
    returnButton = Button(screen, 0, 100, 500, 100)

    startButton.bind(lambda: tractor.send(b'Go'))
    stopButton.bind(lambda: tractor.send(b'Stop'))
    reportButton.bind(lambda: sendReportToFile(tractor))

    startButton.setText("Start Tractor")
    stopButton.setText("Stop Tractor")
    reportButton.setText("Generate Report")
    returnButton.setText("Return")

    running = True
    while running:

        screen.fill((255, 255, 255))

        startButton.draw()
        stopButton.draw()
        reportButton.draw()

        pygame.display.update()

        for event in pygame.event.get():

            if event.type == pygame.QUIT:
                running = False;
                await tractor.quit()
                pygame.quit()

            if event.type == pygame.MOUSEBUTTONUP:
                pos = pygame.mouse.get_pos()

                if startButton.inside(pos[0], pos[1]):
                    await startButton.run()

                if stopButton.inside(pos[0], pos[1]):
                    await stopButton.run()

                if reportButton.inside(pos[0], pos[1]):
                    reportButton.run()

        await asyncio.sleep(0.1)


tractor = Tractor.Tractor()

asyncio.run(main())

